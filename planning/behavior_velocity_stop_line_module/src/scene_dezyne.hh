// Generated by dzn code from /home/pankaj/autoware.SMV/src/universe/autoware.universe/planning/behavior_velocity_stop_line_module/src/scene_dezyne.dzn
#include <dzn/runtime.hh>
namespace dzn
{
  struct locator;
  struct runtime;
}
#include <iostream>
#include <vector>
#include <map>
#ifndef IAPPROACHSTATE_HH
#define IAPPROACHSTATE_HH
struct IApproachState
{
  enum struct State
    {
      APPROACH,STOPPED,START
    };
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<::IApproachState::State ()> updateState;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ::IApproachState::State state;
  IApproachState (dzn::port::meta const& m);
  template <typename Component>
  IApproachState (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , state (::IApproachState::State::APPROACH)
    {
      in.updateState.set (that, this, "updateState");
    }
  virtual ~IApproachState ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IApproachState& provide, ::IApproachState& require)
    {
      require.in.updateState = provide.in.updateState;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
namespace dzn
{
  char const* to_cstr (::IApproachState::State v);
  template <>
  std::string to_string (::IApproachState::State v);
}
template <typename Char, typename Traits>
std::basic_ostream<Char, Traits> & operator << (std::basic_ostream<Char, Traits>& os, ::IApproachState::State v)
{
  return os << dzn::to_cstr (v);
}
namespace dzn
{
  ::IApproachState::State to_IApproachState_State (std::string s);
}
#endif // IAPPROACHSTATE_HH
#ifndef IAPPROACH_HH
#define IAPPROACH_HH
struct IApproach
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> ApproachStuff;
      dzn::in::event<bool ()> StopPointReached;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IApproach (dzn::port::meta const& m);
  template <typename Component>
  IApproach (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.ApproachStuff.set (that, this, "ApproachStuff");
      in.StopPointReached.set (that, this, "StopPointReached");
    }
  virtual ~IApproach ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IApproach& provide, ::IApproach& require)
    {
      require.in.ApproachStuff = provide.in.ApproachStuff;
      require.in.StopPointReached = provide.in.StopPointReached;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // IAPPROACH_HH
#ifndef ISTOPPED_HH
#define ISTOPPED_HH
struct IStopped
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> StoppedStuff;
      dzn::in::event<bool ()> StopTimeElapsed;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IStopped (dzn::port::meta const& m);
  template <typename Component>
  IStopped (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.StoppedStuff.set (that, this, "StoppedStuff");
      in.StopTimeElapsed.set (that, this, "StopTimeElapsed");
    }
  virtual ~IStopped ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IStopped& provide, ::IStopped& require)
    {
      require.in.StoppedStuff = provide.in.StoppedStuff;
      require.in.StopTimeElapsed = provide.in.StopTimeElapsed;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISTOPPED_HH
#ifndef ISTART_HH
#define ISTART_HH
struct IStart
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<::IApproachState::State ()> StartStuff;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IStart (dzn::port::meta const& m);
  template <typename Component>
  IStart (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.StartStuff.set (that, this, "StartStuff");
    }
  virtual ~IStart ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IStart& provide, ::IStart& require)
    {
      require.in.StartStuff = provide.in.StartStuff;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISTART_HH
#ifndef APPROACHSTATEHANDLER_HH
#define APPROACHSTATEHANDLER_HH
struct ApproachStateHandler: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  ::IApproachState::State* dzn_reply_IApproachState_State;
  bool* dzn_reply_bool;
  std::function<void ()>* dzn_out_approachState;
  ::IApproachState approachState;
  ::IApproach approach;
  ::IStart start;
  ::IStopped stop;
  ApproachStateHandler (dzn::locator const& locator);
  private:
  void approachState_updateState ();
};
#endif // APPROACHSTATEHANDLER_HH
// version 2.18.1
