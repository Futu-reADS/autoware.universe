// Generated by dzn code from /home/pankaj/autoware.SMV/src/universe/autoware.universe/planning/surround_obstacle_checker/src/surround_obstacle_checker_dezyne.dzn
#include "surround_obstacle_checker_dezyne.hh"
#include <dzn/locator.hh>
#include <dzn/runtime.hh>
#include <iterator>
#define STRINGIZING(x) #x
#define STR(x) STRINGIZING (x)
#define LOCATION __FILE__ ":" STR (__LINE__)
IStoppingState::IStoppingState (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, state (::IStoppingState::State::PASS)
{}
IStoppingState::~IStoppingState ()= default;
void
IStoppingState::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IStoppingState::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 1867015005u:
      //0:stoppingState
      dzn_state = 1;
      break;
      case 2337162324u:
      //1:State:PASS
      dzn_state = 0;
      state = IStoppingState::State::PASS;
      break;
      case 601847139u:
      //1:State:STOP
      dzn_state = 2;
      state = IStoppingState::State::STOP;
      break;
      case 1867015163u:
      //2:stoppingState
      dzn_state = 1;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IStoppingState::dzn_check_bindings ()
{
  if (!this->in.stoppingState) throw dzn::binding_error (this->dzn_meta, "in.stoppingState");
}
namespace dzn
{
}
namespace dzn
{
  char const*
  to_cstr (::IStoppingState::State v)
    {
      switch (v)
        {
          case ::IStoppingState::State::PASS: return "State:PASS";
          case ::IStoppingState::State::STOP: return "State:STOP";
        }
      return "";
    }
  template <>
  std::string
  to_string (::IStoppingState::State v)
    {
      return to_cstr (v);
    }
}
namespace dzn
{
  ::IStoppingState::State
  to_IStoppingState_State (std::string s)
    {
      static std::map<std::string, ::IStoppingState::State> m =   {
            {"State:PASS", ::IStoppingState::State::PASS},
            {"State:STOP", ::IStoppingState::State::STOP}};
      return m.at (s);
    }
}
IVelocityLimit::IVelocityLimit (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
IVelocityLimit::~IVelocityLimit ()= default;
void
IVelocityLimit::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IVelocityLimit::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 3728269517u:
      //0:passVelocityLimitClearPub
      dzn_state = 1;
      break;
      case 93120110u:
      //0:stopVelocityLimitPub
      dzn_state = 1;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IVelocityLimit::dzn_check_bindings ()
{
  if (!this->in.stopVelocityLimitPub) throw dzn::binding_error (this->dzn_meta, "in.stopVelocityLimitPub");
  if (!this->in.passVelocityLimitClearPub) throw dzn::binding_error (this->dzn_meta, "in.passVelocityLimitClearPub");
}
namespace dzn
{
}
IStatus::IStatus (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
IStatus::~IStatus ()= default;
void
IStatus::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IStatus::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 2262035359u:
      //0:getElaspedTimeClearance
      dzn_state = 1;
      break;
      case 1430660025u:
      //0:getObstacleStatusDuringPass
      dzn_state = 1;
      break;
      case 474864218u:
      //0:getObstacleStatusDuringStop
      dzn_state = 1;
      break;
      case 1775508659u:
      //0:getVehicleStoppingStatus
      dzn_state = 1;
      break;
      case 2489929490u:
      //1:false
      dzn_state = 0;
      break;
      case 1417291072u:
      //1:true
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IStatus::dzn_check_bindings ()
{
  if (!this->in.getObstacleStatusDuringPass) throw dzn::binding_error (this->dzn_meta, "in.getObstacleStatusDuringPass");
  if (!this->in.getObstacleStatusDuringStop) throw dzn::binding_error (this->dzn_meta, "in.getObstacleStatusDuringStop");
  if (!this->in.getVehicleStoppingStatus) throw dzn::binding_error (this->dzn_meta, "in.getVehicleStoppingStatus");
  if (!this->in.getElaspedTimeClearance) throw dzn::binding_error (this->dzn_meta, "in.getElaspedTimeClearance");
}
namespace dzn
{
}
ILastObstacleTime::ILastObstacleTime (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
ILastObstacleTime::~ILastObstacleTime ()= default;
void
ILastObstacleTime::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
ILastObstacleTime::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 2331462225u:
      //0:resetLastObstacleTime
      dzn_state = 1;
      break;
      case 1897697444u:
      //0:setLastObstacleTime
      dzn_state = 1;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
ILastObstacleTime::dzn_check_bindings ()
{
  if (!this->in.setLastObstacleTime) throw dzn::binding_error (this->dzn_meta, "in.setLastObstacleTime");
  if (!this->in.resetLastObstacleTime) throw dzn::binding_error (this->dzn_meta, "in.resetLastObstacleTime");
}
namespace dzn
{
}
surroundObstacleChecker::surroundObstacleChecker (dzn::locator const& locator)
: dzn_meta ({"surroundObstacleChecker","surroundObstacleChecker",0,  {},  {},  {[this] ()
        {
          setStoppingState.dzn_check_bindings ();
        }, [this] ()
        {
          velocityLimit.dzn_check_bindings ();
        }, [this] ()
        {
          status.dzn_check_bindings ();
        }, [this] ()
        {
          lastObstacleTime.dzn_check_bindings ();
        }}})
, dzn_runtime (locator.get<dzn::runtime> ())
, dzn_locator (locator)
, setStoppingState ({  {"setStoppingState",&setStoppingState,this,&dzn_meta},  {"setStoppingState",0,0,0}},this)
, velocityLimit ({  {"velocityLimit",0,0,0},  {"velocityLimit",&velocityLimit,this,&dzn_meta}},this)
, status ({  {"status",0,0,0},  {"status",&status,this,&dzn_meta}},this)
, lastObstacleTime ({  {"lastObstacleTime",0,0,0},  {"lastObstacleTime",&lastObstacleTime,this,&dzn_meta}},this)
{
  this->dzn_meta.require =   {&velocityLimit.dzn_meta,&status.dzn_meta,&lastObstacleTime.dzn_meta};
  this->dzn_runtime.performs_flush (this) = true;
  this->setStoppingState.in.stoppingState = [this] ()
    {
      this->dzn_out_setStoppingState = &this->setStoppingState.in.stoppingState.dzn_out_binding;
      this->dzn_reply_IStoppingState_State = &this->setStoppingState.in.stoppingState.reply;
      this->setStoppingState_stoppingState ();
      return this->setStoppingState.in.stoppingState.reply;
    };
}
void
surroundObstacleChecker::setStoppingState_stoppingState ()
{
  if (setStoppingState.state == ::IStoppingState::State::PASS)
    {
      bool dzn_tmp0 = this->status.in.getVehicleStoppingStatus ();
      if (!this->is_stop_required (dzn_tmp0, this->status.in.getObstacleStatusDuringPass ()))
        {
          *this->dzn_reply_IStoppingState_State = setStoppingState.state;
          if ((*this->dzn_out_setStoppingState)) (*this->dzn_out_setStoppingState) ();
          (*this->dzn_out_setStoppingState) = nullptr;
        }
      else
        {
          this->velocityLimit.in.stopVelocityLimitPub ();
          *this->dzn_reply_IStoppingState_State = ::IStoppingState::State::STOP;
          if ((*this->dzn_out_setStoppingState)) (*this->dzn_out_setStoppingState) ();
          (*this->dzn_out_setStoppingState) = nullptr;
        }
    }
  else if (setStoppingState.state == ::IStoppingState::State::STOP)
    {
      bool dzn_tmp1 = this->status.in.getVehicleStoppingStatus ();
      if (this->is_stop_required (dzn_tmp1, this->status.in.getObstacleStatusDuringPass ()))
        {
          *this->dzn_reply_IStoppingState_State = setStoppingState.state;
          if ((*this->dzn_out_setStoppingState)) (*this->dzn_out_setStoppingState) ();
          (*this->dzn_out_setStoppingState) = nullptr;
        }
      else
        {
          this->velocityLimit.in.passVelocityLimitClearPub ();
          *this->dzn_reply_IStoppingState_State = ::IStoppingState::State::PASS;
          if ((*this->dzn_out_setStoppingState)) (*this->dzn_out_setStoppingState) ();
          (*this->dzn_out_setStoppingState) = nullptr;
        }
    }
  else if (!(setStoppingState.state == ::IStoppingState::State::STOP) && !(setStoppingState.state == ::IStoppingState::State::PASS)) this->dzn_locator.get<dzn::illegal_handler> ().handle (LOCATION);
  else this->dzn_locator.get<dzn::illegal_handler> ().handle (LOCATION);
}
bool
surroundObstacleChecker::is_stop_required (bool is_vehicle_stopped, bool is_obstacle_found)
{
  if (!is_vehicle_stopped)
    {
      return false;
    }
  if (is_obstacle_found)
    {
      this->lastObstacleTime.in.setLastObstacleTime ();
      return true;
    }
  if (setStoppingState.state == ::IStoppingState::State::PASS)
    {
      return false;
    }
  if (this->status.in.getElaspedTimeClearance ())
    {
      return true;
    }
  this->lastObstacleTime.in.resetLastObstacleTime ();
  return false;
}
// version 2.18.1
