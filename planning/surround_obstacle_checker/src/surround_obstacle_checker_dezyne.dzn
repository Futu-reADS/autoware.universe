interface IStoppingState
{
  in State stoppingState();
  enum State {STOP, PASS};

  behavior
  {
    State state = State.STOP;
    [state.STOP || state.PASS] {
      on stoppingState: {
        state = State.PASS;
        reply(state);
      }
      on stoppingState: {
        state = State.STOP;
        reply(state);
      }
    }
  }
}

interface IVelocityLimit {
  in void stopVelocityLimitPub();
  in void passVelocityLimitClearPub();
  behavior {
    on stopVelocityLimitPub: {}
    on passVelocityLimitClearPub: {}
  }
}

interface IStatus
{
  in bool getObstacleStatusDuringPass();
  in bool getObstacleStatusDuringStop();
  in bool getVehicleStoppingStatus();
  in bool getElaspedTimeClearance();

  behavior
  {
    on getObstacleStatusDuringPass: reply(true);
    on getObstacleStatusDuringPass: reply(false);
    on getObstacleStatusDuringStop: reply(true);
    on getObstacleStatusDuringStop: reply(false);
    on getVehicleStoppingStatus: reply(true);
    on getVehicleStoppingStatus: reply(false);
    on getElaspedTimeClearance: reply(true);
    on getElaspedTimeClearance: reply(false);
  }
}

interface ILastObstacleTime
{
  in void setLastObstacleTime();
  in void resetLastObstacleTime();

  behavior
  {
    on setLastObstacleTime: {}
    on resetLastObstacleTime: {}
  }
}

component surroundObstacleChecker {
  provides IStoppingState setStoppingState;
  requires IStoppingState getStoppingState;
  requires IVelocityLimit velocityLimit;
  requires IStatus status;
  requires ILastObstacleTime lastObstacleTime;

  

  behavior {
    on setStoppingState.stoppingState(): {
      // I would read the parameters once
      IStoppingState.State currentState = setStoppingState.state;
      IStoppingState.State nextState = getStoppingState.stoppingState();
      bool vehicleStopping = status.getVehicleStoppingStatus();

      if(currentState.PASS && vehicleStopping) {
          if (status.getObstacleStatusDuringPass()){
            lastObstacleTime.setLastObstacleTime();
            velocityLimit.stopVelocityLimitPub();
            nextState = IStoppingState.State.STOP;
          }
          else {
            if (nextState == IStoppingState.State.STOP && !status.getElaspedTimeClearance()) {
              lastObstacleTime.resetLastObstacleTime();
            } else if (nextState == IStoppingState.State.STOP) {
              velocityLimit.stopVelocityLimitPub();
            }
          }
      }
      else if(currentState.STOP) {
        if (vehicleStopping) {
          if (status.getObstacleStatusDuringStop()){
            lastObstacleTime.setLastObstacleTime();
          }
          else {
            if (!status.getElaspedTimeClearance()) {
              lastObstacleTime.resetLastObstacleTime();
              velocityLimit.passVelocityLimitClearPub();
              nextState = IStoppingState.State.PASS;
            }
            else if (nextState != IStoppingState.State.STOP || status.getElaspedTimeClearance()) {
              velocityLimit.passVelocityLimitClearPub();
              nextState = IStoppingState.State.PASS;
            }
          }
        }
        else {
          velocityLimit.passVelocityLimitClearPub();
          nextState = IStoppingState.State.PASS;
        }
      }
      reply(nextState);
    }
  }
}