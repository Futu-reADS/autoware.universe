// Generated by dzn code from /home/karol/autoware/src/universe/autoware.universe/planning/surround_obstacle_checker/src/surround_obstacle_checker_dezyne.dzn
#include <dzn/runtime.hh>
namespace dzn
{
  struct locator;
  struct runtime;
}
#include <iostream>
#include <vector>
#include <map>
#ifndef ISTOPPINGSTATE_HH
#define ISTOPPINGSTATE_HH
struct IStoppingState
{
  enum struct State
    {
      STOP,PASS
    };
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<::IStoppingState::State ()> stoppingState;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ::IStoppingState::State state;
  IStoppingState (dzn::port::meta const& m);
  template <typename Component>
  IStoppingState (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , state (::IStoppingState::State::PASS)
    {
      in.stoppingState.set (that, this, "stoppingState");
    }
  virtual ~IStoppingState ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IStoppingState& provide, ::IStoppingState& require)
    {
      require.in.stoppingState = provide.in.stoppingState;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
namespace dzn
{
  char const* to_cstr (::IStoppingState::State v);
  template <>
  std::string to_string (::IStoppingState::State v);
}
template <typename Char, typename Traits>
std::basic_ostream<Char, Traits> & operator << (std::basic_ostream<Char, Traits>& os, ::IStoppingState::State v)
{
  return os << dzn::to_cstr (v);
}
namespace dzn
{
  ::IStoppingState::State to_IStoppingState_State (std::string s);
}
#endif // ISTOPPINGSTATE_HH
#ifndef IVELOCITYLIMIT_HH
#define IVELOCITYLIMIT_HH
struct IVelocityLimit
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> stopVelocityLimitPub;
      dzn::in::event<void ()> passVelocityLimitClearPub;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IVelocityLimit (dzn::port::meta const& m);
  template <typename Component>
  IVelocityLimit (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.stopVelocityLimitPub.set (that, this, "stopVelocityLimitPub");
      in.passVelocityLimitClearPub.set (that, this, "passVelocityLimitClearPub");
    }
  virtual ~IVelocityLimit ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IVelocityLimit& provide, ::IVelocityLimit& require)
    {
      require.in.stopVelocityLimitPub = provide.in.stopVelocityLimitPub;
      require.in.passVelocityLimitClearPub = provide.in.passVelocityLimitClearPub;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // IVELOCITYLIMIT_HH
#ifndef ISTATUS_HH
#define ISTATUS_HH
struct IStatus
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<bool ()> getObstacleStatusDuringPass;
      dzn::in::event<bool ()> getObstacleStatusDuringStop;
      dzn::in::event<bool ()> getVehicleStoppingStatus;
      dzn::in::event<bool ()> getElaspedTimeClearance;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IStatus (dzn::port::meta const& m);
  template <typename Component>
  IStatus (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.getObstacleStatusDuringPass.set (that, this, "getObstacleStatusDuringPass");
      in.getObstacleStatusDuringStop.set (that, this, "getObstacleStatusDuringStop");
      in.getVehicleStoppingStatus.set (that, this, "getVehicleStoppingStatus");
      in.getElaspedTimeClearance.set (that, this, "getElaspedTimeClearance");
    }
  virtual ~IStatus ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IStatus& provide, ::IStatus& require)
    {
      require.in.getObstacleStatusDuringPass = provide.in.getObstacleStatusDuringPass;
      require.in.getObstacleStatusDuringStop = provide.in.getObstacleStatusDuringStop;
      require.in.getVehicleStoppingStatus = provide.in.getVehicleStoppingStatus;
      require.in.getElaspedTimeClearance = provide.in.getElaspedTimeClearance;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISTATUS_HH
#ifndef ILASTOBSTACLETIME_HH
#define ILASTOBSTACLETIME_HH
struct ILastObstacleTime
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> setLastObstacleTime;
      dzn::in::event<void ()> resetLastObstacleTime;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ILastObstacleTime (dzn::port::meta const& m);
  template <typename Component>
  ILastObstacleTime (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.setLastObstacleTime.set (that, this, "setLastObstacleTime");
      in.resetLastObstacleTime.set (that, this, "resetLastObstacleTime");
    }
  virtual ~ILastObstacleTime ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::ILastObstacleTime& provide, ::ILastObstacleTime& require)
    {
      require.in.setLastObstacleTime = provide.in.setLastObstacleTime;
      require.in.resetLastObstacleTime = provide.in.resetLastObstacleTime;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ILASTOBSTACLETIME_HH
#ifndef SURROUNDOBSTACLECHECKER_HH
#define SURROUNDOBSTACLECHECKER_HH
struct surroundObstacleChecker: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  ::IStoppingState::State* dzn_reply_IStoppingState_State;
  bool* dzn_reply_bool;
  std::function<void ()>* dzn_out_setStoppingState;
  ::IStoppingState setStoppingState;
  ::IVelocityLimit velocityLimit;
  ::IStatus status;
  ::ILastObstacleTime lastObstacleTime;
  surroundObstacleChecker (dzn::locator const& locator);
  private:
  void setStoppingState_stoppingState ();
  bool is_stop_required (bool is_obstacle_found, bool is_vehicle_stopped);
};
#endif // SURROUNDOBSTACLECHECKER_HH
// version 2.18.1
